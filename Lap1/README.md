## Лабораторная работа №1

# Плохой Dockerfile

![docker img](./public/docker1.png)

FROM node:18: указывает базовый образ Node.js версии 18. Этот образ доступен в официальном репозитории Node.js Docker Hub.

WORKDIR /app: устанавливает рабочий каталог внутри контейнера в /app. Это каталог, в котором будут выполняться последующие команды.

КОПИРОВАТЬ. .: копирует все файлы и каталоги из локального контекста (каталог, в котором находится файл Dockerfile) в каталог /app в контейнере. Сюда входит код вашего приложения, package.json и любые другие файлы.

RUN Yarn install: устанавливает зависимости приложения Node.js с помощью менеджера пакетов Yarn. Эта команда основана на файлах package.json и Yarn.lock, скопированных на предыдущем шаге.

RUN Yarn build: строит приложение. Предполагается, что в разделе сценариев файла package.json определен сценарий сборки, обычно это что-то вроде «build»: «some-build-command».

CMD ["yarn", "start"]: устанавливает команду по умолчанию, запускаемую при запуске контейнера. Это запустит приложение с помощью команды запуска пряжи. Если при запуске контейнера не указана команда, эта команда будет выполнена по умолчанию.

# Хороший Dockerfile

![docker img](./public/docker2.png)

Этот Dockerfile представляет собой многоэтапную сборку, предназначенную для приложения Node.js, скорее всего, приложения Next.js. Он использует несколько этапов для оптимизации размера получаемого образа Docker и отделения зависимостей разработки от рабочего образа. Давайте разберем каждый раздел:

1. **изображение глубины:**

   ```Dockerfile
   ОТ узла: 18 в зависимости от

   РАБОЧИЙ ПАРАМЕТР/приложение
   КОПИРОВАТЬ package.json Yarn.lock ./

   RUN Yarn install --frozen-lockfile
   ```

   - Этот этап называется «депс».
   - Устанавливает рабочий каталог `/app`.
     — Копирует в рабочий каталог только package.json и Yarn.lock.
     — Устанавливает зависимости с помощью Yarn install с флагом --frozen-lockfile, что обеспечивает воспроизводимость за счет использования точных версий, указанных в файле блокировки.

2. **BUILD_IMAGE:**

   ```Dockerfile
   ОТ узла: 18 как BUILD_IMAGE

   РАБОЧИЙ ПАРАМЕТР/приложение
   КОПИЯ --from=deps /app/node_modules ./node_modules
   КОПИРОВАТЬ. .
   Сборка пряжи RUN
   ВЫПОЛНИТЬ rm -rf node_modules
   RUN Yarn install --production --frozen-lockfile --ignore-scripts --prefer-offline
   ```

   - Этот этап называется BUILD_IMAGE.
   - Устанавливает рабочий каталог `/app`.
     — Копирует каталог node_modules со стадии deps.
   - Копирует весь исходный код приложения.
   - Собирает приложение с помощью Yarn build.
     — Удаляет зависимости разработки («node_modules»).
     — Устанавливает только производственные зависимости с дополнительными флагами для оптимизации (`--production`, `--ignore-scripts`, `--prefer-offline`).

3. **Окончательный результат:**

   ```Dockerfile
   ОТ узла: 18

   ЗАПУСК addgroup --system --gid 1001 nodejs
   ЗАПУСК adduser --system --uid 1001 nextjs

   РАБОЧИЙ ДИАПАЗОН/приложение

   КОПИРОВАТЬ --from=BUILD_IMAGE --chown=nextjs:nodejs /app/package.json /app/yarn.lock ./
   КОПИРОВАТЬ --from=BUILD_IMAGE --chown=nextjs:nodejs /app/node_modules ./node_modules
   КОПИРОВАТЬ --from=BUILD_IMAGE --chown=nextjs:nodejs /app/public ./public
   КОПИРОВАТЬ --from=BUILD_IMAGE --chown=nextjs:nodejs /app/.next ./.next

   ПОЛЬЗОВАТЕЛЬ nextjs

   ЭКСПОЗИЦИЯ 3000

   CMD ["пряжа", "начало"]
   ```

   - Использует окончательное изображение `node:18`.
     — Создает системную группу и пользователя («nodejs» и «nextjs») с указанными UID и GID.
   - Устанавливает рабочий каталог `/app`.
   - Копирует файлы со стадии `BUILD_IMAGE`, настраивая владельца с помощью `chown`.
   - Переключается на пользователя nextjs.
   - Открывает порт 3000.
   - Определяет команду по умолчанию для запуска приложения: `yarn start`.

---

Предоставленный вами Dockerfile.better имеет многоэтапную сборку, которая обычно считается лучшей практикой для оптимизации образов Docker. Многоэтапные сборки помогают уменьшить размер окончательного образа за счет использования промежуточных образов для построения зависимостей и последующего копирования в итоговый образ только необходимых артефактов.

Вот некоторые преимущества первого Dockerfile (многоэтапная сборка):

1. Меньший окончательный размер изображения:

   - Окончательный образ, вероятно, будет меньше, поскольку он включает только необходимые файлы и зависимости, скопированные с промежуточных шагов. Это может привести к более быстрому и эффективному получению и развертыванию изображений.

2. Уменьшенная поверхность атаки:

   - Окончательный образ содержит только встроенные артефакты и зависимости времени выполнения, что сводит к минимуму поверхность атаки. Промежуточные шаги, используемые для построения зависимостей и приложения, отбрасываются, что снижает риск включения ненужных инструментов или библиотек в окончательный образ.

3. Быстрая сборка:

   - Разделив этапы сборки, вы можете воспользоваться преимуществами кэширования слоев. Если зависимости и исходный код не изменились, Docker может повторно использовать кэшированные слои с предыдущих этапов, что ускоряет процесс сборки.

4. Четкое разделение интересов:
   - Каждый этап Dockerfile несет определенную ответственность (например, построение зависимостей, сборка приложения, создание окончательного образа среды выполнения). Такое четкое разделение задач может сделать Dockerfile более удобным и понятным.

С другой стороны, Dockerfile — это более простая одноэтапная сборка. Хотя это проще, в результате может получиться более крупный окончательный образ, а также включить в окончательный образ зависимости разработки, которые могут не потребоваться для производственной среды.

Таким образом, Dockerfile.better с многоэтапной сборкой обычно предпочтительнее для промышленного использования из-за его преимуществ с точки зрения размера образа, безопасности и эффективности сборки. Dockerfile может больше подойти для разработки или в ситуациях, когда размер образа не имеет решающего значения.

Размер изображения dockerfile :
![result img](./public/result_docker.png)

Результат выпольнил:
![result img2](./public/result2.png)
